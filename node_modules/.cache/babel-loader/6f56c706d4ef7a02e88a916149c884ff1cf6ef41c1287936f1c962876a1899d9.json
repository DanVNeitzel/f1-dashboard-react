{"ast":null,"code":"import axios from 'axios';\nconst BASE_URL = 'https://api.openf1.org/v1';\n\n// FunÃ§Ã£o auxiliar para adicionar delay entre requisiÃ§Ãµes (respeitar rate limit da API)\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// Rate limiter - mÃ¡ximo 3 requisiÃ§Ãµes por segundo\nlet requestQueue = [];\nlet isProcessing = false;\nconst rateLimitedRequest = async requestFn => {\n  return new Promise((resolve, reject) => {\n    requestQueue.push({\n      requestFn,\n      resolve,\n      reject\n    });\n    processQueue();\n  });\n};\nconst processQueue = async () => {\n  if (isProcessing || requestQueue.length === 0) return;\n  isProcessing = true;\n  const batch = requestQueue.splice(0, 3); // Processar atÃ© 3 por vez\n\n  try {\n    const results = await Promise.all(batch.map(({\n      requestFn,\n      resolve,\n      reject\n    }) => requestFn().then(resolve).catch(reject)));\n    if (requestQueue.length > 0) {\n      await delay(1000); // Aguardar 1 segundo antes do prÃ³ximo lote\n      isProcessing = false;\n      processQueue();\n    } else {\n      isProcessing = false;\n    }\n  } catch (error) {\n    isProcessing = false;\n    throw error;\n  }\n};\n\n// FunÃ§Ã£o para obter a Ãºltima sessÃ£o ativa\nexport const getLatestSession = async () => {\n  try {\n    const now = new Date();\n    const year = now.getFullYear();\n\n    // Buscar todas as corridas do ano atual\n    const response = await axios.get(`${BASE_URL}/sessions?session_name=Race&year=${year}`);\n    const sessions = response.data;\n    if (sessions.length === 0) {\n      return null;\n    }\n\n    // Filtrar sessÃµes que jÃ¡ aconteceram (data_end anterior Ã  data atual)\n    const pastSessions = sessions.filter(session => {\n      const endDate = new Date(session.date_end);\n      return endDate <= now;\n    });\n\n    // Se houver sessÃµes passadas, retornar a mais recente\n    if (pastSessions.length > 0) {\n      const latestPastSession = pastSessions.sort((a, b) => new Date(b.date_end) - new Date(a.date_end))[0];\n      console.log('ðŸ“… Ãšltima corrida vÃ¡lida:', latestPastSession.country_name, latestPastSession.date_end);\n      return latestPastSession;\n    }\n\n    // Se nÃ£o hÃ¡ sessÃµes passadas, retornar a primeira futura (caso estejamos no inÃ­cio da temporada)\n    const futureSessions = sessions.filter(session => {\n      const startDate = new Date(session.date_start);\n      return startDate > now;\n    });\n    if (futureSessions.length > 0) {\n      const nextSession = futureSessions.sort((a, b) => new Date(a.date_start) - new Date(b.date_start))[0];\n      console.log('ðŸ“… PrÃ³xima corrida:', nextSession.country_name, nextSession.date_start);\n      return nextSession;\n    }\n\n    // Fallback: retornar a Ãºltima sessÃ£o disponÃ­vel\n    return sessions[sessions.length - 1];\n  } catch (error) {\n    console.error('Erro ao buscar sessÃ£o:', error);\n    return null;\n  }\n};\n\n// FunÃ§Ã£o para verificar se hÃ¡ uma sessÃ£o ativa no momento\nexport const checkActiveSession = async () => {\n  try {\n    const now = new Date();\n    const year = now.getFullYear();\n\n    // Buscar todas as sessÃµes do ano atual\n    const response = await axios.get(`${BASE_URL}/sessions?year=${year}`);\n    const sessions = response.data;\n    if (sessions.length === 0) {\n      return {\n        isActive: false,\n        currentSession: null,\n        nextSession: null\n      };\n    }\n\n    // Verificar se hÃ¡ uma sessÃ£o acontecendo agora\n    const activeSession = sessions.find(session => {\n      const start = new Date(session.date_start);\n      const end = new Date(session.date_end);\n      return now >= start && now <= end;\n    });\n    if (activeSession) {\n      return {\n        isActive: true,\n        currentSession: activeSession,\n        nextSession: null\n      };\n    }\n\n    // Se nÃ£o hÃ¡ sessÃ£o ativa, encontrar a prÃ³xima\n    const futureSessions = sessions.filter(session => new Date(session.date_start) > now);\n    const nextSession = futureSessions.length > 0 ? futureSessions[0] : null;\n    return {\n      isActive: false,\n      currentSession: null,\n      nextSession\n    };\n  } catch (error) {\n    console.error('Erro ao verificar sessÃ£o ativa:', error);\n    return {\n      isActive: false,\n      currentSession: null,\n      nextSession: null\n    };\n  }\n};\n\n// FunÃ§Ã£o para obter as prÃ³ximas sessÃµes\nexport const getUpcomingSessions = async (limit = 5) => {\n  try {\n    const now = new Date();\n    const year = now.getFullYear();\n    const response = await axios.get(`${BASE_URL}/sessions?year=${year}`);\n    const sessions = response.data;\n\n    // Filtrar sessÃµes futuras e ordenar por data\n    const upcoming = sessions.filter(session => new Date(session.date_start) > now).sort((a, b) => new Date(a.date_start) - new Date(b.date_start)).slice(0, limit);\n    return upcoming;\n  } catch (error) {\n    console.error('Erro ao buscar prÃ³ximas sessÃµes:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter todas as sessÃµes de um meeting especÃ­fico\nexport const getMeetingSessions = async meetingKey => {\n  try {\n    const response = await axios.get(`${BASE_URL}/sessions?meeting_key=${meetingKey}`);\n    return response.data;\n  } catch (error) {\n    console.error('Erro ao buscar sessÃµes do meeting:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter todas as sessÃµes de um ano\nexport const getSessionsByYear = async year => {\n  try {\n    const response = await axios.get(`${BASE_URL}/sessions?year=${year}`);\n    return response.data;\n  } catch (error) {\n    console.error('Erro ao buscar sessÃµes do ano:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter sessÃµes por paÃ­s e ano\nexport const getSessionsByCountry = async (year, countryName) => {\n  try {\n    const response = await axios.get(`${BASE_URL}/sessions?year=${year}&country_name=${countryName}`);\n    return response.data;\n  } catch (error) {\n    console.error('Erro ao buscar sessÃµes por paÃ­s:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o helper para buscar dados de sessÃ£o\nconst getSessionInfo = async sessionKey => {\n  try {\n    const response = await axios.get(`${BASE_URL}/sessions?session_key=${sessionKey}`);\n    return response.data.length > 0 ? response.data[0] : null;\n  } catch (error) {\n    console.error('Erro ao buscar informaÃ§Ãµes da sessÃ£o:', error);\n    return null;\n  }\n};\n\n// FunÃ§Ã£o para obter classificaÃ§Ã£o final baseada na Ãºltima volta\nexport const getRaceClassification = async sessionKey => {\n  try {\n    console.log('ðŸ Buscando classificaÃ§Ã£o final da corrida...');\n\n    // DSQ conhecidos (desqualificaÃ§Ãµes pÃ³s-corrida nÃ£o aparecem na API)\n    // Las Vegas 2025 - Norris e Piastri desqualificados por infraÃ§Ãµes tÃ©cnicas\n    const knownDSQ = {\n      9858: [4, 81] // session_key 9858: carros 4 (Norris) e 81 (Piastri)\n    };\n    const dsqDrivers = knownDSQ[sessionKey] || [];\n\n    // Buscar todas as voltas\n    const response = await axios.get(`${BASE_URL}/laps?session_key=${sessionKey}`);\n    const allLaps = response.data;\n    if (allLaps.length === 0) {\n      console.warn('Nenhuma volta encontrada');\n      return [];\n    }\n\n    // Encontrar o nÃºmero mÃ¡ximo de voltas completadas\n    const maxLapNumber = Math.max(...allLaps.map(lap => lap.lap_number));\n    console.log(`ðŸ“Š Corrida teve ${maxLapNumber} voltas`);\n\n    // Pegar Ãºltima volta de cada piloto\n    const driverLastLaps = {};\n    allLaps.forEach(lap => {\n      const driverNum = lap.driver_number;\n      if (!driverLastLaps[driverNum] || lap.lap_number > driverLastLaps[driverNum].lap_number) {\n        driverLastLaps[driverNum] = lap;\n      }\n    });\n\n    // Buscar todos os drivers da sessÃ£o para identificar quem nÃ£o largou\n    const driversResponse = await axios.get(`${BASE_URL}/drivers?session_key=${sessionKey}`);\n    const allDrivers = driversResponse.data;\n\n    // Separar pilotos que completaram a corrida, DNF, DSQ e DNS (nÃ£o largaram)\n    const finishers = [];\n    const dnfDrivers = [];\n    const dsqDriversList = [];\n    const dnsDrivers = [];\n    allDrivers.forEach(driver => {\n      const lap = driverLastLaps[driver.driver_number];\n\n      // Verificar se estÃ¡ na lista de DSQ\n      if (dsqDrivers.includes(driver.driver_number)) {\n        dsqDriversList.push({\n          driver_number: driver.driver_number,\n          lap_number: (lap === null || lap === void 0 ? void 0 : lap.lap_number) || 0,\n          date_start: (lap === null || lap === void 0 ? void 0 : lap.date_start) || null,\n          status: 'DSQ'\n        });\n      } else if (!lap || lap.lap_number === 0) {\n        // Piloto nÃ£o completou nenhuma volta - DNS ou DNF na largada\n        dnsDrivers.push({\n          driver_number: driver.driver_number,\n          lap_number: 0,\n          date_start: null,\n          status: 'DNF'\n        });\n      } else if (lap.lap_number === maxLapNumber) {\n        // Completou todas as voltas\n        finishers.push({\n          ...lap,\n          status: 'CLASSIFIED'\n        });\n      } else {\n        // DNF - nÃ£o completou a corrida\n        dnfDrivers.push({\n          ...lap,\n          status: 'DNF'\n        });\n      }\n    });\n\n    // Ordenar finishers pela ordem de chegada (date_start da Ãºltima volta)\n    finishers.sort((a, b) => new Date(a.date_start) - new Date(b.date_start));\n\n    // Ordenar DNF por nÃºmero de voltas completadas (decrescente), depois por data\n    dnfDrivers.sort((a, b) => {\n      if (b.lap_number !== a.lap_number) {\n        return b.lap_number - a.lap_number;\n      }\n      if (a.date_start && b.date_start) {\n        return new Date(b.date_start) - new Date(a.date_start);\n      }\n      return 0;\n    });\n\n    // DNS vÃ£o por Ãºltimo\n    dnsDrivers.sort((a, b) => a.driver_number - b.driver_number);\n\n    // DSQ ordenados por nÃºmero do carro\n    dsqDriversList.sort((a, b) => a.driver_number - b.driver_number);\n\n    // Combinar classificaÃ§Ã£o\n    let position = 1;\n    const classification = [];\n\n    // Finishers recebem posiÃ§Ãµes normais (1, 2, 3...)\n    finishers.forEach(lap => {\n      classification.push({\n        position: position++,\n        driver_number: lap.driver_number,\n        lap_number: lap.lap_number,\n        date_start: lap.date_start,\n        status: 'CLASSIFIED',\n        displayPosition: position - 1\n      });\n    });\n\n    // DNF aparecem como \"NC\" (Not Classified) ou mantÃ©m posiÃ§Ã£o numÃ©rica\n    dnfDrivers.forEach(lap => {\n      classification.push({\n        position: position++,\n        driver_number: lap.driver_number,\n        lap_number: lap.lap_number,\n        date_start: lap.date_start,\n        status: 'DNF',\n        displayPosition: 'NC'\n      });\n    });\n\n    // DNS aparecem como \"NC\"\n    dnsDrivers.forEach(lap => {\n      classification.push({\n        position: position++,\n        driver_number: lap.driver_number,\n        lap_number: lap.lap_number,\n        date_start: lap.date_start,\n        status: 'DNF',\n        displayPosition: 'NC'\n      });\n    });\n\n    // DSQ aparecem como \"DQ\" (Disqualified)\n    dsqDriversList.forEach(lap => {\n      classification.push({\n        position: position++,\n        driver_number: lap.driver_number,\n        lap_number: lap.lap_number,\n        date_start: lap.date_start,\n        status: 'DSQ',\n        displayPosition: 'DQ'\n      });\n    });\n    console.log('ðŸ† ClassificaÃ§Ã£o final:');\n    console.log('  Finishers:', finishers.length);\n    console.log('  DNF:', dnfDrivers.length);\n    console.log('  DNS:', dnsDrivers.length);\n    console.log('  DSQ:', dsqDriversList.length);\n    classification.slice(0, 25).forEach(c => {\n      const pos = typeof c.displayPosition === 'number' ? `P${c.displayPosition}` : c.displayPosition;\n      console.log(`  ${pos}: #${c.driver_number} - ${c.lap_number} voltas (${c.status})`);\n    });\n    return classification;\n  } catch (error) {\n    console.error('Erro ao buscar classificaÃ§Ã£o:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter dados de posiÃ§Ã£o dos pilotos (otimizado com limite)\nexport const getPositions = async sessionKey => {\n  try {\n    // Buscar informaÃ§Ãµes da sessÃ£o\n    const session = await getSessionInfo(sessionKey);\n    if (!session || !session.date_end) {\n      // Se nÃ£o tem data_end (sessÃ£o ao vivo), buscar dados limitados\n      const response = await axios.get(`${BASE_URL}/position?session_key=${sessionKey}`);\n      const data = response.data;\n      // Retornar apenas os Ãºltimos 500 registros\n      return data.length > 500 ? data.slice(-500) : data;\n    }\n\n    // Para sessÃµes finalizadas, buscar os Ãºltimos 10 segundos para ter posiÃ§Ãµes finais\n    const endDate = new Date(session.date_end);\n    const startDate = new Date(endDate.getTime() - 10000); // Ãšltimos 10 segundos\n\n    console.log(`ðŸ“ Buscando posiÃ§Ãµes finais dos Ãºltimos 10s da corrida...`);\n    const response = await axios.get(`${BASE_URL}/position?session_key=${sessionKey}&date>=${startDate.toISOString().split('.')[0]}`);\n    console.log(`âœ… ${response.data.length} registros de posiÃ§Ã£o retornados`);\n    return response.data;\n  } catch (error) {\n    console.error('Erro ao buscar posiÃ§Ãµes:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter dados dos pilotos (sem modificaÃ§Ã£o - Ã© pequeno)\nexport const getDrivers = async sessionKey => {\n  try {\n    const response = await axios.get(`${BASE_URL}/drivers?session_key=${sessionKey}`);\n    return response.data;\n  } catch (error) {\n    console.error('Erro ao buscar pilotos:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter dados de voltas (otimizado - apenas Ãºltima volta de cada piloto)\nexport const getLaps = async sessionKey => {\n  try {\n    const response = await axios.get(`${BASE_URL}/laps?session_key=${sessionKey}`);\n    const data = response.data;\n\n    // Se houver muitos dados, pegar apenas as Ãºltimas voltas de cada piloto\n    if (data.length > 100) {\n      const latestLaps = {};\n      data.forEach(lap => {\n        const key = lap.driver_number;\n        if (!latestLaps[key] || lap.lap_number > latestLaps[key].lap_number) {\n          latestLaps[key] = lap;\n        }\n      });\n      return Object.values(latestLaps);\n    }\n    return data;\n  } catch (error) {\n    console.error('Erro ao buscar voltas:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter dados de intervalos (otimizado - apenas Ãºltimos registros)\nexport const getIntervals = async sessionKey => {\n  try {\n    const response = await axios.get(`${BASE_URL}/intervals?session_key=${sessionKey}`);\n    const data = response.data;\n\n    // Se houver muitos dados, pegar apenas os Ãºltimos intervalos de cada piloto\n    if (data.length > 100) {\n      const latestIntervals = {};\n      data.forEach(interval => {\n        const key = interval.driver_number;\n        if (!latestIntervals[key] || new Date(interval.date) > new Date(latestIntervals[key].date)) {\n          latestIntervals[key] = interval;\n        }\n      });\n      return Object.values(latestIntervals);\n    }\n    return data;\n  } catch (error) {\n    console.error('Erro ao buscar intervalos:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter dados de pit stops (desabilitado - muitos dados)\nexport const getPitStops = async sessionKey => {\n  try {\n    // Endpoint /pit pode retornar mais de 4MB de dados\n    // Desabilitado para evitar exceder o limite da API\n    console.warn('Pit endpoint desabilitado - usando stints para informaÃ§Ãµes de pneus');\n    return [];\n  } catch (error) {\n    console.error('Erro ao buscar pit stops:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter dados de stints (perÃ­odos com o mesmo pneu) - otimizado\nexport const getStints = async sessionKey => {\n  try {\n    const response = await axios.get(`${BASE_URL}/stints?session_key=${sessionKey}`);\n    const data = response.data;\n\n    // Stints geralmente tem poucos dados, mas vamos garantir\n    if (data.length > 200) {\n      // Pegar apenas os stints mais recentes de cada piloto\n      const latestStints = {};\n      data.forEach(stint => {\n        const key = stint.driver_number;\n        if (!latestStints[key] || stint.stint_number > latestStints[key].stint_number) {\n          latestStints[key] = stint;\n        }\n      });\n      return Object.values(latestStints);\n    }\n    return data;\n  } catch (error) {\n    console.error('Erro ao buscar stints:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter dados de localizaÃ§Ã£o dos pilotos (apenas posiÃ§Ãµes mais recentes)\nexport const getLocations = async sessionKey => {\n  try {\n    // Buscar informaÃ§Ãµes da sessÃ£o para pegar data final\n    const session = await getSessionInfo(sessionKey);\n    if (!session) {\n      console.warn('SessÃ£o nÃ£o encontrada para buscar locations');\n      return [];\n    }\n\n    // Se a sessÃ£o nÃ£o tem data_end, buscar apenas Ãºltimos 30 segundos\n    const endDate = session.date_end ? new Date(session.date_end) : new Date();\n    const startDate = new Date(endDate.getTime() - 30000); // Ãšltimos 30 segundos\n\n    console.log(`ðŸ—ºï¸ Buscando locations dos Ãºltimos 30s (${startDate.toISOString()} atÃ© ${endDate.toISOString()})`);\n    const response = await axios.get(`${BASE_URL}/location?session_key=${sessionKey}&date>=${startDate.toISOString().split('.')[0]}&date<=${endDate.toISOString().split('.')[0]}`);\n    const locationData = response.data;\n\n    // Pegar apenas a Ãºltima posiÃ§Ã£o de cada piloto\n    const latestLocations = {};\n    locationData.forEach(loc => {\n      const key = loc.driver_number;\n      if (!latestLocations[key] || new Date(loc.date) > new Date(latestLocations[key].date)) {\n        latestLocations[key] = loc;\n      }\n    });\n    const result = Object.values(latestLocations);\n    console.log(`âœ… Location carregado: ${result.length} pilotos (de ${locationData.length} registros)`);\n    return result;\n  } catch (error) {\n    console.error('âŒ Erro ao buscar localizaÃ§Ãµes:', error.message);\n    // Se ainda falhar, tentar buscar apenas Ãºltimos 10 segundos\n    try {\n      console.log('ðŸ”„ Tentando com janela de 10 segundos...');\n      const session = await getSessionInfo(sessionKey);\n      const endDate = session !== null && session !== void 0 && session.date_end ? new Date(session.date_end) : new Date();\n      const startDate = new Date(endDate.getTime() - 10000); // Ãšltimos 10 segundos\n\n      const response = await axios.get(`${BASE_URL}/location?session_key=${sessionKey}&date>=${startDate.toISOString().split('.')[0]}&date<=${endDate.toISOString().split('.')[0]}`);\n      const locationData = response.data;\n      const latestLocations = {};\n      locationData.forEach(loc => {\n        const key = loc.driver_number;\n        if (!latestLocations[key] || new Date(loc.date) > new Date(latestLocations[key].date)) {\n          latestLocations[key] = loc;\n        }\n      });\n      const result = Object.values(latestLocations);\n      console.log(`âœ… Location carregado (10s): ${result.length} pilotos`);\n      return result;\n    } catch (secondError) {\n      console.warn('âŒ Location endpoint falhou mesmo com janela reduzida - desabilitado');\n      return [];\n    }\n  }\n};\n\n// FunÃ§Ã£o para obter dados meteorolÃ³gicos (desabilitado - muitos dados)\nexport const getWeather = async sessionKey => {\n  try {\n    // Endpoint /weather pode retornar mais de 4MB de dados histÃ³ricos\n    // Desabilitado para evitar exceder o limite da API\n    console.warn('Weather endpoint desabilitado - muitos dados histÃ³ricos');\n    return [];\n  } catch (error) {\n    console.error('Erro ao buscar clima:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter rÃ¡dio da equipe (otimizado - apenas Ãºltimas mensagens)\nexport const getTeamRadio = async sessionKey => {\n  try {\n    const response = await axios.get(`${BASE_URL}/team_radio?session_key=${sessionKey}`);\n    const data = response.data;\n\n    // Limitar a Ãºltimas 50 mensagens para evitar exceder 4MB\n    if (data.length > 50) {\n      return data.slice(-50);\n    }\n    return data;\n  } catch (error) {\n    console.error('Erro ao buscar rÃ¡dio da equipe:', error);\n    // Se exceder o limite de dados, retornar array vazio\n    if (error.response && (error.response.status === 429 || error.response.status === 413)) {\n      console.warn('Team radio endpoint excedeu limite - desabilitado');\n    }\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter eventos de controle da corrida (desabilitado - muitos dados)\nexport const getRaceControl = async sessionKey => {\n  try {\n    // Endpoint /race_control pode retornar mais de 4MB de dados\n    // Desabilitado para evitar exceder o limite da API\n    console.warn('Race control endpoint desabilitado - muitos dados histÃ³ricos');\n    return [];\n  } catch (error) {\n    console.error('Erro ao buscar controle da corrida:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o para obter dados de telemetria do carro\nexport const getCarData = async (sessionKey, driverNumber) => {\n  try {\n    const response = await axios.get(`${BASE_URL}/car_data?session_key=${sessionKey}&driver_number=${driverNumber}`);\n    return response.data;\n  } catch (error) {\n    console.error('Erro ao buscar dados do carro:', error);\n    return [];\n  }\n};\n\n// FunÃ§Ã£o FORÃ‡ADA para tentar buscar Ãºltimos dados vÃ¡lidos (ignora limitaÃ§Ãµes)\nexport const getSessionDataForced = async sessionKey => {\n  try {\n    if (!sessionKey) {\n      return {\n        drivers: [],\n        positions: [],\n        laps: [],\n        intervals: [],\n        locations: [],\n        pitStops: [],\n        stints: [],\n        weather: [],\n        teamRadio: [],\n        raceControl: [],\n        session: null\n      };\n    }\n    console.warn('ðŸš€ MODO FORÃ‡ADO ATIVADO - Tentando buscar Ãºltimos dados vÃ¡lidos...');\n    const results = {\n      drivers: [],\n      positions: [],\n      laps: [],\n      intervals: [],\n      locations: [],\n      pitStops: [],\n      stints: [],\n      weather: [],\n      teamRadio: [],\n      raceControl: [],\n      session: null,\n      classification: []\n    };\n\n    // Tentar buscar cada endpoint com timeout e tratamento de erro individual\n    // Lote 1 - Drivers\n    try {\n      results.drivers = await getDrivers(sessionKey);\n      console.log('âœ… Drivers carregados:', results.drivers.length);\n    } catch (e) {\n      console.warn('âŒ Erro ao carregar drivers:', e.message);\n    }\n    await delay(3000);\n\n    // Lote 1.5 - ClassificaÃ§Ã£o final\n    try {\n      results.classification = await getRaceClassification(sessionKey);\n      console.log('âœ… ClassificaÃ§Ã£o carregada:', results.classification.length);\n    } catch (e) {\n      console.warn('âŒ Erro ao carregar classificaÃ§Ã£o:', e.message);\n    }\n    await delay(3000);\n\n    // Lote 2 - Laps (apenas Ãºltimas voltas)\n    try {\n      results.laps = await getLaps(sessionKey);\n      console.log('âœ… Laps carregados:', results.laps.length);\n    } catch (e) {\n      console.warn('âŒ Erro ao carregar laps:', e.message);\n    }\n    await delay(3000);\n\n    // Lote 3 - Intervals (apenas Ãºltimos)\n    try {\n      results.intervals = await getIntervals(sessionKey);\n      console.log('âœ… Intervals carregados:', results.intervals.length);\n    } catch (e) {\n      console.warn('âŒ Erro ao carregar intervals:', e.message);\n    }\n    await delay(3000);\n\n    // Lote 4 - Positions (apenas Ãºltimos)\n    try {\n      results.positions = await getPositions(sessionKey);\n      console.log('âœ… Positions carregados:', results.positions.length);\n    } catch (e) {\n      console.warn('âŒ Erro ao carregar positions:', e.message);\n    }\n    await delay(3000);\n\n    // Lote 5 - Stints\n    try {\n      results.stints = await getStints(sessionKey);\n      console.log('âœ… Stints carregados:', results.stints.length);\n    } catch (e) {\n      console.warn('âŒ Erro ao carregar stints:', e.message);\n    }\n    await delay(3000);\n\n    // Lote 6 - Team Radio (Ãºltimas 20 mensagens)\n    try {\n      results.teamRadio = await getTeamRadio(sessionKey);\n      console.log('âœ… Team Radio carregado:', results.teamRadio.length);\n    } catch (e) {\n      console.warn('âŒ Erro ao carregar team radio:', e.message);\n    }\n    await delay(3000);\n\n    // Lote 7 - Weather (tentar buscar Ãºltimos dados climÃ¡ticos)\n    try {\n      console.log('â³ Tentando carregar Weather...');\n      const weatherResponse = await axios.get(`${BASE_URL}/weather?session_key=${sessionKey}`);\n      const weatherData = weatherResponse.data;\n      // Pegar apenas os Ãºltimos 10 registros\n      results.weather = weatherData.length > 10 ? weatherData.slice(-10) : weatherData;\n      console.log('âœ… Weather carregado:', results.weather.length);\n    } catch (e) {\n      console.warn('âŒ Erro ao carregar weather:', e.message);\n      results.weather = [];\n    }\n    await delay(3000);\n\n    // Lote 8 - Location (usar funÃ§Ã£o otimizada)\n    try {\n      console.log('â³ Tentando carregar Location (Ãºltimos 30s)...');\n      results.locations = await getLocations(sessionKey);\n    } catch (e) {\n      console.warn('âŒ Erro ao carregar location:', e.message);\n      results.locations = [];\n    }\n    await delay(3000);\n\n    // Lote 9 - Race Control (Ãºltimos 30 eventos)\n    try {\n      console.log('â³ Tentando carregar Race Control...');\n      const raceControlResponse = await axios.get(`${BASE_URL}/race_control?session_key=${sessionKey}`);\n      const raceControlData = raceControlResponse.data;\n      // Pegar apenas os Ãºltimos 30 eventos\n      results.raceControl = raceControlData.length > 30 ? raceControlData.slice(-30) : raceControlData;\n      console.log('âœ… Race Control carregado:', results.raceControl.length);\n    } catch (e) {\n      console.warn('âŒ Erro ao carregar race control:', e.message);\n      results.raceControl = [];\n    }\n    console.log('ðŸ Carregamento forÃ§ado concluÃ­do!');\n    console.log('ðŸ“Š Resumo:', {\n      drivers: results.drivers.length,\n      positions: results.positions.length,\n      laps: results.laps.length,\n      intervals: results.intervals.length,\n      stints: results.stints.length,\n      teamRadio: results.teamRadio.length,\n      weather: results.weather.length,\n      locations: results.locations.length,\n      raceControl: results.raceControl.length\n    });\n    return results;\n  } catch (error) {\n    console.error('Erro geral ao buscar dados forÃ§ados:', error);\n    return {\n      drivers: [],\n      positions: [],\n      laps: [],\n      intervals: [],\n      locations: [],\n      pitStops: [],\n      stints: [],\n      weather: [],\n      teamRadio: [],\n      raceControl: [],\n      session: null\n    };\n  }\n};\n\n// FunÃ§Ã£o para obter dados completos de uma sessÃ£o especÃ­fica\nexport const getSessionData = async sessionKey => {\n  try {\n    if (!sessionKey) {\n      return {\n        drivers: [],\n        positions: [],\n        laps: [],\n        intervals: [],\n        locations: [],\n        pitStops: [],\n        stints: [],\n        weather: [],\n        teamRadio: [],\n        raceControl: [],\n        session: null,\n        classification: []\n      };\n    }\n\n    // ESTRATÃ‰GIA CONSERVADORA: Para sessÃµes com muitos dados histÃ³ricos (como 9869),\n    // vamos buscar apenas os dados ESSENCIAIS para evitar exceder 4MB/10s\n\n    // Lote 1 - APENAS drivers (pequeno, sempre funciona)\n    const drivers = await getDrivers(sessionKey);\n    await delay(2000); // Aguardar 2 segundos\n\n    // Buscar classificaÃ§Ã£o final baseada nas voltas\n    const classification = await getRaceClassification(sessionKey);\n    await delay(2000);\n\n    // Todos os outros dados desabilitados temporariamente devido aos limites da API\n    // A sessÃ£o selecionada (9869) contÃ©m dados histÃ³ricos muito grandes\n    const positions = [];\n    const laps = [];\n    const intervals = [];\n    const stints = [];\n    const teamRadio = [];\n    const locations = [];\n    const pitStops = [];\n    const raceControl = [];\n    const weather = [];\n\n    // Buscar informaÃ§Ãµes da sessÃ£o\n    const sessionResponse = await axios.get(`${BASE_URL}/sessions?session_key=${sessionKey}`);\n    const session = sessionResponse.data.length > 0 ? sessionResponse.data[0] : null;\n    return {\n      drivers,\n      positions,\n      laps,\n      intervals,\n      locations,\n      pitStops,\n      stints,\n      weather,\n      teamRadio,\n      raceControl,\n      session,\n      classification\n    };\n  } catch (error) {\n    console.error('Erro ao buscar dados da sessÃ£o:', error);\n    return {\n      drivers: [],\n      positions: [],\n      laps: [],\n      intervals: [],\n      locations: [],\n      pitStops: [],\n      stints: [],\n      weather: [],\n      teamRadio: [],\n      raceControl: [],\n      session: null,\n      classification: []\n    };\n  }\n};\n\n// FunÃ§Ã£o para processar e combinar dados\nexport const getFullRaceData = async (sessionKey = null, forceLoad = false) => {\n  try {\n    let session = null;\n    let targetSessionKey = sessionKey;\n\n    // Se nÃ£o foi fornecido sessionKey, buscar a Ãºltima sessÃ£o\n    if (!targetSessionKey) {\n      session = await getLatestSession();\n      if (!session) {\n        return {\n          drivers: [],\n          positions: [],\n          laps: [],\n          intervals: [],\n          locations: [],\n          pitStops: [],\n          stints: [],\n          weather: [],\n          teamRadio: [],\n          raceControl: [],\n          session: null\n        };\n      }\n      targetSessionKey = session.session_key;\n    }\n\n    // Buscar dados da sessÃ£o especÃ­fica\n    const data = forceLoad ? await getSessionDataForced(targetSessionKey) : await getSessionData(targetSessionKey);\n\n    // Se a sessÃ£o nÃ£o foi buscada ainda, buscar agora\n    if (!data.session && targetSessionKey) {\n      const sessionResponse = await axios.get(`${BASE_URL}/sessions?session_key=${targetSessionKey}`);\n      data.session = sessionResponse.data.length > 0 ? sessionResponse.data[0] : session;\n    } else if (!data.session) {\n      data.session = session;\n    }\n    return data;\n  } catch (error) {\n    console.error('Erro ao buscar dados completos:', error);\n    return {\n      drivers: [],\n      positions: [],\n      laps: [],\n      intervals: [],\n      locations: [],\n      pitStops: [],\n      stints: [],\n      weather: [],\n      teamRadio: [],\n      raceControl: [],\n      session: null\n    };\n  }\n};","map":{"version":3,"names":["axios","BASE_URL","delay","ms","Promise","resolve","setTimeout","requestQueue","isProcessing","rateLimitedRequest","requestFn","reject","push","processQueue","length","batch","splice","results","all","map","then","catch","error","getLatestSession","now","Date","year","getFullYear","response","get","sessions","data","pastSessions","filter","session","endDate","date_end","latestPastSession","sort","a","b","console","log","country_name","futureSessions","startDate","date_start","nextSession","checkActiveSession","isActive","currentSession","activeSession","find","start","end","getUpcomingSessions","limit","upcoming","slice","getMeetingSessions","meetingKey","getSessionsByYear","getSessionsByCountry","countryName","getSessionInfo","sessionKey","getRaceClassification","knownDSQ","dsqDrivers","allLaps","warn","maxLapNumber","Math","max","lap","lap_number","driverLastLaps","forEach","driverNum","driver_number","driversResponse","allDrivers","finishers","dnfDrivers","dsqDriversList","dnsDrivers","driver","includes","status","position","classification","displayPosition","c","pos","getPositions","getTime","toISOString","split","getDrivers","getLaps","latestLaps","key","Object","values","getIntervals","latestIntervals","interval","date","getPitStops","getStints","latestStints","stint","stint_number","getLocations","locationData","latestLocations","loc","result","message","secondError","getWeather","getTeamRadio","getRaceControl","getCarData","driverNumber","getSessionDataForced","drivers","positions","laps","intervals","locations","pitStops","stints","weather","teamRadio","raceControl","e","weatherResponse","weatherData","raceControlResponse","raceControlData","getSessionData","sessionResponse","getFullRaceData","forceLoad","targetSessionKey","session_key"],"sources":["/workspaces/f1-dashboard-react/src/services/api.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst BASE_URL = 'https://api.openf1.org/v1';\r\n\r\n// FunÃ§Ã£o auxiliar para adicionar delay entre requisiÃ§Ãµes (respeitar rate limit da API)\r\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\n// Rate limiter - mÃ¡ximo 3 requisiÃ§Ãµes por segundo\r\nlet requestQueue = [];\r\nlet isProcessing = false;\r\n\r\nconst rateLimitedRequest = async (requestFn) => {\r\n  return new Promise((resolve, reject) => {\r\n    requestQueue.push({ requestFn, resolve, reject });\r\n    processQueue();\r\n  });\r\n};\r\n\r\nconst processQueue = async () => {\r\n  if (isProcessing || requestQueue.length === 0) return;\r\n  \r\n  isProcessing = true;\r\n  const batch = requestQueue.splice(0, 3); // Processar atÃ© 3 por vez\r\n  \r\n  try {\r\n    const results = await Promise.all(\r\n      batch.map(({ requestFn, resolve, reject }) =>\r\n        requestFn().then(resolve).catch(reject)\r\n      )\r\n    );\r\n    \r\n    if (requestQueue.length > 0) {\r\n      await delay(1000); // Aguardar 1 segundo antes do prÃ³ximo lote\r\n      isProcessing = false;\r\n      processQueue();\r\n    } else {\r\n      isProcessing = false;\r\n    }\r\n  } catch (error) {\r\n    isProcessing = false;\r\n    throw error;\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter a Ãºltima sessÃ£o ativa\r\nexport const getLatestSession = async () => {\r\n  try {\r\n    const now = new Date();\r\n    const year = now.getFullYear();\r\n    \r\n    // Buscar todas as corridas do ano atual\r\n    const response = await axios.get(`${BASE_URL}/sessions?session_name=Race&year=${year}`);\r\n    const sessions = response.data;\r\n    \r\n    if (sessions.length === 0) {\r\n      return null;\r\n    }\r\n    \r\n    // Filtrar sessÃµes que jÃ¡ aconteceram (data_end anterior Ã  data atual)\r\n    const pastSessions = sessions.filter(session => {\r\n      const endDate = new Date(session.date_end);\r\n      return endDate <= now;\r\n    });\r\n    \r\n    // Se houver sessÃµes passadas, retornar a mais recente\r\n    if (pastSessions.length > 0) {\r\n      const latestPastSession = pastSessions.sort((a, b) => \r\n        new Date(b.date_end) - new Date(a.date_end)\r\n      )[0];\r\n      console.log('ðŸ“… Ãšltima corrida vÃ¡lida:', latestPastSession.country_name, latestPastSession.date_end);\r\n      return latestPastSession;\r\n    }\r\n    \r\n    // Se nÃ£o hÃ¡ sessÃµes passadas, retornar a primeira futura (caso estejamos no inÃ­cio da temporada)\r\n    const futureSessions = sessions.filter(session => {\r\n      const startDate = new Date(session.date_start);\r\n      return startDate > now;\r\n    });\r\n    \r\n    if (futureSessions.length > 0) {\r\n      const nextSession = futureSessions.sort((a, b) => \r\n        new Date(a.date_start) - new Date(b.date_start)\r\n      )[0];\r\n      console.log('ðŸ“… PrÃ³xima corrida:', nextSession.country_name, nextSession.date_start);\r\n      return nextSession;\r\n    }\r\n    \r\n    // Fallback: retornar a Ãºltima sessÃ£o disponÃ­vel\r\n    return sessions[sessions.length - 1];\r\n  } catch (error) {\r\n    console.error('Erro ao buscar sessÃ£o:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para verificar se hÃ¡ uma sessÃ£o ativa no momento\r\nexport const checkActiveSession = async () => {\r\n  try {\r\n    const now = new Date();\r\n    const year = now.getFullYear();\r\n    \r\n    // Buscar todas as sessÃµes do ano atual\r\n    const response = await axios.get(`${BASE_URL}/sessions?year=${year}`);\r\n    const sessions = response.data;\r\n    \r\n    if (sessions.length === 0) {\r\n      return { isActive: false, currentSession: null, nextSession: null };\r\n    }\r\n    \r\n    // Verificar se hÃ¡ uma sessÃ£o acontecendo agora\r\n    const activeSession = sessions.find(session => {\r\n      const start = new Date(session.date_start);\r\n      const end = new Date(session.date_end);\r\n      return now >= start && now <= end;\r\n    });\r\n    \r\n    if (activeSession) {\r\n      return { isActive: true, currentSession: activeSession, nextSession: null };\r\n    }\r\n    \r\n    // Se nÃ£o hÃ¡ sessÃ£o ativa, encontrar a prÃ³xima\r\n    const futureSessions = sessions.filter(session => new Date(session.date_start) > now);\r\n    const nextSession = futureSessions.length > 0 ? futureSessions[0] : null;\r\n    \r\n    return { isActive: false, currentSession: null, nextSession };\r\n  } catch (error) {\r\n    console.error('Erro ao verificar sessÃ£o ativa:', error);\r\n    return { isActive: false, currentSession: null, nextSession: null };\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter as prÃ³ximas sessÃµes\r\nexport const getUpcomingSessions = async (limit = 5) => {\r\n  try {\r\n    const now = new Date();\r\n    const year = now.getFullYear();\r\n    \r\n    const response = await axios.get(`${BASE_URL}/sessions?year=${year}`);\r\n    const sessions = response.data;\r\n    \r\n    // Filtrar sessÃµes futuras e ordenar por data\r\n    const upcoming = sessions\r\n      .filter(session => new Date(session.date_start) > now)\r\n      .sort((a, b) => new Date(a.date_start) - new Date(b.date_start))\r\n      .slice(0, limit);\r\n    \r\n    return upcoming;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar prÃ³ximas sessÃµes:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter todas as sessÃµes de um meeting especÃ­fico\r\nexport const getMeetingSessions = async (meetingKey) => {\r\n  try {\r\n    const response = await axios.get(`${BASE_URL}/sessions?meeting_key=${meetingKey}`);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar sessÃµes do meeting:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter todas as sessÃµes de um ano\r\nexport const getSessionsByYear = async (year) => {\r\n  try {\r\n    const response = await axios.get(`${BASE_URL}/sessions?year=${year}`);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar sessÃµes do ano:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter sessÃµes por paÃ­s e ano\r\nexport const getSessionsByCountry = async (year, countryName) => {\r\n  try {\r\n    const response = await axios.get(`${BASE_URL}/sessions?year=${year}&country_name=${countryName}`);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar sessÃµes por paÃ­s:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o helper para buscar dados de sessÃ£o\r\nconst getSessionInfo = async (sessionKey) => {\r\n  try {\r\n    const response = await axios.get(`${BASE_URL}/sessions?session_key=${sessionKey}`);\r\n    return response.data.length > 0 ? response.data[0] : null;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar informaÃ§Ãµes da sessÃ£o:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter classificaÃ§Ã£o final baseada na Ãºltima volta\r\nexport const getRaceClassification = async (sessionKey) => {\r\n  try {\r\n    console.log('ðŸ Buscando classificaÃ§Ã£o final da corrida...');\r\n    \r\n    // DSQ conhecidos (desqualificaÃ§Ãµes pÃ³s-corrida nÃ£o aparecem na API)\r\n    // Las Vegas 2025 - Norris e Piastri desqualificados por infraÃ§Ãµes tÃ©cnicas\r\n    const knownDSQ = {\r\n      9858: [4, 81] // session_key 9858: carros 4 (Norris) e 81 (Piastri)\r\n    };\r\n    \r\n    const dsqDrivers = knownDSQ[sessionKey] || [];\r\n    \r\n    // Buscar todas as voltas\r\n    const response = await axios.get(`${BASE_URL}/laps?session_key=${sessionKey}`);\r\n    const allLaps = response.data;\r\n    \r\n    if (allLaps.length === 0) {\r\n      console.warn('Nenhuma volta encontrada');\r\n      return [];\r\n    }\r\n    \r\n    // Encontrar o nÃºmero mÃ¡ximo de voltas completadas\r\n    const maxLapNumber = Math.max(...allLaps.map(lap => lap.lap_number));\r\n    console.log(`ðŸ“Š Corrida teve ${maxLapNumber} voltas`);\r\n    \r\n    // Pegar Ãºltima volta de cada piloto\r\n    const driverLastLaps = {};\r\n    allLaps.forEach(lap => {\r\n      const driverNum = lap.driver_number;\r\n      if (!driverLastLaps[driverNum] || lap.lap_number > driverLastLaps[driverNum].lap_number) {\r\n        driverLastLaps[driverNum] = lap;\r\n      }\r\n    });\r\n    \r\n    // Buscar todos os drivers da sessÃ£o para identificar quem nÃ£o largou\r\n    const driversResponse = await axios.get(`${BASE_URL}/drivers?session_key=${sessionKey}`);\r\n    const allDrivers = driversResponse.data;\r\n    \r\n    // Separar pilotos que completaram a corrida, DNF, DSQ e DNS (nÃ£o largaram)\r\n    const finishers = [];\r\n    const dnfDrivers = [];\r\n    const dsqDriversList = [];\r\n    const dnsDrivers = [];\r\n    \r\n    allDrivers.forEach(driver => {\r\n      const lap = driverLastLaps[driver.driver_number];\r\n      \r\n      // Verificar se estÃ¡ na lista de DSQ\r\n      if (dsqDrivers.includes(driver.driver_number)) {\r\n        dsqDriversList.push({\r\n          driver_number: driver.driver_number,\r\n          lap_number: lap?.lap_number || 0,\r\n          date_start: lap?.date_start || null,\r\n          status: 'DSQ'\r\n        });\r\n      } else if (!lap || lap.lap_number === 0) {\r\n        // Piloto nÃ£o completou nenhuma volta - DNS ou DNF na largada\r\n        dnsDrivers.push({\r\n          driver_number: driver.driver_number,\r\n          lap_number: 0,\r\n          date_start: null,\r\n          status: 'DNF'\r\n        });\r\n      } else if (lap.lap_number === maxLapNumber) {\r\n        // Completou todas as voltas\r\n        finishers.push({\r\n          ...lap,\r\n          status: 'CLASSIFIED'\r\n        });\r\n      } else {\r\n        // DNF - nÃ£o completou a corrida\r\n        dnfDrivers.push({\r\n          ...lap,\r\n          status: 'DNF'\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Ordenar finishers pela ordem de chegada (date_start da Ãºltima volta)\r\n    finishers.sort((a, b) => new Date(a.date_start) - new Date(b.date_start));\r\n    \r\n    // Ordenar DNF por nÃºmero de voltas completadas (decrescente), depois por data\r\n    dnfDrivers.sort((a, b) => {\r\n      if (b.lap_number !== a.lap_number) {\r\n        return b.lap_number - a.lap_number;\r\n      }\r\n      if (a.date_start && b.date_start) {\r\n        return new Date(b.date_start) - new Date(a.date_start);\r\n      }\r\n      return 0;\r\n    });\r\n    \r\n    // DNS vÃ£o por Ãºltimo\r\n    dnsDrivers.sort((a, b) => a.driver_number - b.driver_number);\r\n    \r\n    // DSQ ordenados por nÃºmero do carro\r\n    dsqDriversList.sort((a, b) => a.driver_number - b.driver_number);\r\n    \r\n    // Combinar classificaÃ§Ã£o\r\n    let position = 1;\r\n    const classification = [];\r\n    \r\n    // Finishers recebem posiÃ§Ãµes normais (1, 2, 3...)\r\n    finishers.forEach(lap => {\r\n      classification.push({\r\n        position: position++,\r\n        driver_number: lap.driver_number,\r\n        lap_number: lap.lap_number,\r\n        date_start: lap.date_start,\r\n        status: 'CLASSIFIED',\r\n        displayPosition: position - 1\r\n      });\r\n    });\r\n    \r\n    // DNF aparecem como \"NC\" (Not Classified) ou mantÃ©m posiÃ§Ã£o numÃ©rica\r\n    dnfDrivers.forEach(lap => {\r\n      classification.push({\r\n        position: position++,\r\n        driver_number: lap.driver_number,\r\n        lap_number: lap.lap_number,\r\n        date_start: lap.date_start,\r\n        status: 'DNF',\r\n        displayPosition: 'NC'\r\n      });\r\n    });\r\n    \r\n    // DNS aparecem como \"NC\"\r\n    dnsDrivers.forEach(lap => {\r\n      classification.push({\r\n        position: position++,\r\n        driver_number: lap.driver_number,\r\n        lap_number: lap.lap_number,\r\n        date_start: lap.date_start,\r\n        status: 'DNF',\r\n        displayPosition: 'NC'\r\n      });\r\n    });\r\n    \r\n    // DSQ aparecem como \"DQ\" (Disqualified)\r\n    dsqDriversList.forEach(lap => {\r\n      classification.push({\r\n        position: position++,\r\n        driver_number: lap.driver_number,\r\n        lap_number: lap.lap_number,\r\n        date_start: lap.date_start,\r\n        status: 'DSQ',\r\n        displayPosition: 'DQ'\r\n      });\r\n    });\r\n    \r\n    console.log('ðŸ† ClassificaÃ§Ã£o final:');\r\n    console.log('  Finishers:', finishers.length);\r\n    console.log('  DNF:', dnfDrivers.length);\r\n    console.log('  DNS:', dnsDrivers.length);\r\n    console.log('  DSQ:', dsqDriversList.length);\r\n    classification.slice(0, 25).forEach(c => {\r\n      const pos = typeof c.displayPosition === 'number' ? `P${c.displayPosition}` : c.displayPosition;\r\n      console.log(`  ${pos}: #${c.driver_number} - ${c.lap_number} voltas (${c.status})`);\r\n    });\r\n    \r\n    return classification;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar classificaÃ§Ã£o:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter dados de posiÃ§Ã£o dos pilotos (otimizado com limite)\r\nexport const getPositions = async (sessionKey) => {\r\n  try {\r\n    // Buscar informaÃ§Ãµes da sessÃ£o\r\n    const session = await getSessionInfo(sessionKey);\r\n    \r\n    if (!session || !session.date_end) {\r\n      // Se nÃ£o tem data_end (sessÃ£o ao vivo), buscar dados limitados\r\n      const response = await axios.get(`${BASE_URL}/position?session_key=${sessionKey}`);\r\n      const data = response.data;\r\n      // Retornar apenas os Ãºltimos 500 registros\r\n      return data.length > 500 ? data.slice(-500) : data;\r\n    }\r\n    \r\n    // Para sessÃµes finalizadas, buscar os Ãºltimos 10 segundos para ter posiÃ§Ãµes finais\r\n    const endDate = new Date(session.date_end);\r\n    const startDate = new Date(endDate.getTime() - 10000); // Ãšltimos 10 segundos\r\n    \r\n    console.log(`ðŸ“ Buscando posiÃ§Ãµes finais dos Ãºltimos 10s da corrida...`);\r\n    \r\n    const response = await axios.get(\r\n      `${BASE_URL}/position?session_key=${sessionKey}&date>=${startDate.toISOString().split('.')[0]}`\r\n    );\r\n    \r\n    console.log(`âœ… ${response.data.length} registros de posiÃ§Ã£o retornados`);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar posiÃ§Ãµes:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter dados dos pilotos (sem modificaÃ§Ã£o - Ã© pequeno)\r\nexport const getDrivers = async (sessionKey) => {\r\n  try {\r\n    const response = await axios.get(`${BASE_URL}/drivers?session_key=${sessionKey}`);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar pilotos:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter dados de voltas (otimizado - apenas Ãºltima volta de cada piloto)\r\nexport const getLaps = async (sessionKey) => {\r\n  try {\r\n    const response = await axios.get(`${BASE_URL}/laps?session_key=${sessionKey}`);\r\n    const data = response.data;\r\n    \r\n    // Se houver muitos dados, pegar apenas as Ãºltimas voltas de cada piloto\r\n    if (data.length > 100) {\r\n      const latestLaps = {};\r\n      data.forEach(lap => {\r\n        const key = lap.driver_number;\r\n        if (!latestLaps[key] || lap.lap_number > latestLaps[key].lap_number) {\r\n          latestLaps[key] = lap;\r\n        }\r\n      });\r\n      return Object.values(latestLaps);\r\n    }\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar voltas:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter dados de intervalos (otimizado - apenas Ãºltimos registros)\r\nexport const getIntervals = async (sessionKey) => {\r\n  try {\r\n    const response = await axios.get(`${BASE_URL}/intervals?session_key=${sessionKey}`);\r\n    const data = response.data;\r\n    \r\n    // Se houver muitos dados, pegar apenas os Ãºltimos intervalos de cada piloto\r\n    if (data.length > 100) {\r\n      const latestIntervals = {};\r\n      data.forEach(interval => {\r\n        const key = interval.driver_number;\r\n        if (!latestIntervals[key] || new Date(interval.date) > new Date(latestIntervals[key].date)) {\r\n          latestIntervals[key] = interval;\r\n        }\r\n      });\r\n      return Object.values(latestIntervals);\r\n    }\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar intervalos:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter dados de pit stops (desabilitado - muitos dados)\r\nexport const getPitStops = async (sessionKey) => {\r\n  try {\r\n    // Endpoint /pit pode retornar mais de 4MB de dados\r\n    // Desabilitado para evitar exceder o limite da API\r\n    console.warn('Pit endpoint desabilitado - usando stints para informaÃ§Ãµes de pneus');\r\n    return [];\r\n  } catch (error) {\r\n    console.error('Erro ao buscar pit stops:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter dados de stints (perÃ­odos com o mesmo pneu) - otimizado\r\nexport const getStints = async (sessionKey) => {\r\n  try {\r\n    const response = await axios.get(`${BASE_URL}/stints?session_key=${sessionKey}`);\r\n    const data = response.data;\r\n    \r\n    // Stints geralmente tem poucos dados, mas vamos garantir\r\n    if (data.length > 200) {\r\n      // Pegar apenas os stints mais recentes de cada piloto\r\n      const latestStints = {};\r\n      data.forEach(stint => {\r\n        const key = stint.driver_number;\r\n        if (!latestStints[key] || stint.stint_number > latestStints[key].stint_number) {\r\n          latestStints[key] = stint;\r\n        }\r\n      });\r\n      return Object.values(latestStints);\r\n    }\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar stints:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter dados de localizaÃ§Ã£o dos pilotos (apenas posiÃ§Ãµes mais recentes)\r\nexport const getLocations = async (sessionKey) => {\r\n  try {\r\n    // Buscar informaÃ§Ãµes da sessÃ£o para pegar data final\r\n    const session = await getSessionInfo(sessionKey);\r\n    \r\n    if (!session) {\r\n      console.warn('SessÃ£o nÃ£o encontrada para buscar locations');\r\n      return [];\r\n    }\r\n\r\n    // Se a sessÃ£o nÃ£o tem data_end, buscar apenas Ãºltimos 30 segundos\r\n    const endDate = session.date_end ? new Date(session.date_end) : new Date();\r\n    const startDate = new Date(endDate.getTime() - 30000); // Ãšltimos 30 segundos\r\n    \r\n    console.log(`ðŸ—ºï¸ Buscando locations dos Ãºltimos 30s (${startDate.toISOString()} atÃ© ${endDate.toISOString()})`);\r\n    \r\n    const response = await axios.get(\r\n      `${BASE_URL}/location?session_key=${sessionKey}&date>=${startDate.toISOString().split('.')[0]}&date<=${endDate.toISOString().split('.')[0]}`\r\n    );\r\n    \r\n    const locationData = response.data;\r\n    \r\n    // Pegar apenas a Ãºltima posiÃ§Ã£o de cada piloto\r\n    const latestLocations = {};\r\n    locationData.forEach(loc => {\r\n      const key = loc.driver_number;\r\n      if (!latestLocations[key] || new Date(loc.date) > new Date(latestLocations[key].date)) {\r\n        latestLocations[key] = loc;\r\n      }\r\n    });\r\n    \r\n    const result = Object.values(latestLocations);\r\n    console.log(`âœ… Location carregado: ${result.length} pilotos (de ${locationData.length} registros)`);\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    console.error('âŒ Erro ao buscar localizaÃ§Ãµes:', error.message);\r\n    // Se ainda falhar, tentar buscar apenas Ãºltimos 10 segundos\r\n    try {\r\n      console.log('ðŸ”„ Tentando com janela de 10 segundos...');\r\n      const session = await getSessionInfo(sessionKey);\r\n      const endDate = session?.date_end ? new Date(session.date_end) : new Date();\r\n      const startDate = new Date(endDate.getTime() - 10000); // Ãšltimos 10 segundos\r\n      \r\n      const response = await axios.get(\r\n        `${BASE_URL}/location?session_key=${sessionKey}&date>=${startDate.toISOString().split('.')[0]}&date<=${endDate.toISOString().split('.')[0]}`\r\n      );\r\n      \r\n      const locationData = response.data;\r\n      const latestLocations = {};\r\n      locationData.forEach(loc => {\r\n        const key = loc.driver_number;\r\n        if (!latestLocations[key] || new Date(loc.date) > new Date(latestLocations[key].date)) {\r\n          latestLocations[key] = loc;\r\n        }\r\n      });\r\n      \r\n      const result = Object.values(latestLocations);\r\n      console.log(`âœ… Location carregado (10s): ${result.length} pilotos`);\r\n      return result;\r\n    } catch (secondError) {\r\n      console.warn('âŒ Location endpoint falhou mesmo com janela reduzida - desabilitado');\r\n      return [];\r\n    }\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter dados meteorolÃ³gicos (desabilitado - muitos dados)\r\nexport const getWeather = async (sessionKey) => {\r\n  try {\r\n    // Endpoint /weather pode retornar mais de 4MB de dados histÃ³ricos\r\n    // Desabilitado para evitar exceder o limite da API\r\n    console.warn('Weather endpoint desabilitado - muitos dados histÃ³ricos');\r\n    return [];\r\n  } catch (error) {\r\n    console.error('Erro ao buscar clima:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter rÃ¡dio da equipe (otimizado - apenas Ãºltimas mensagens)\r\nexport const getTeamRadio = async (sessionKey) => {\r\n  try {\r\n    const response = await axios.get(`${BASE_URL}/team_radio?session_key=${sessionKey}`);\r\n    const data = response.data;\r\n    \r\n    // Limitar a Ãºltimas 50 mensagens para evitar exceder 4MB\r\n    if (data.length > 50) {\r\n      return data.slice(-50);\r\n    }\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar rÃ¡dio da equipe:', error);\r\n    // Se exceder o limite de dados, retornar array vazio\r\n    if (error.response && (error.response.status === 429 || error.response.status === 413)) {\r\n      console.warn('Team radio endpoint excedeu limite - desabilitado');\r\n    }\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter eventos de controle da corrida (desabilitado - muitos dados)\r\nexport const getRaceControl = async (sessionKey) => {\r\n  try {\r\n    // Endpoint /race_control pode retornar mais de 4MB de dados\r\n    // Desabilitado para evitar exceder o limite da API\r\n    console.warn('Race control endpoint desabilitado - muitos dados histÃ³ricos');\r\n    return [];\r\n  } catch (error) {\r\n    console.error('Erro ao buscar controle da corrida:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter dados de telemetria do carro\r\nexport const getCarData = async (sessionKey, driverNumber) => {\r\n  try {\r\n    const response = await axios.get(`${BASE_URL}/car_data?session_key=${sessionKey}&driver_number=${driverNumber}`);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar dados do carro:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o FORÃ‡ADA para tentar buscar Ãºltimos dados vÃ¡lidos (ignora limitaÃ§Ãµes)\r\nexport const getSessionDataForced = async (sessionKey) => {\r\n  try {\r\n    if (!sessionKey) {\r\n      return { \r\n        drivers: [], \r\n        positions: [], \r\n        laps: [], \r\n        intervals: [], \r\n        locations: [], \r\n        pitStops: [], \r\n        stints: [],\r\n        weather: [],\r\n        teamRadio: [],\r\n        raceControl: [],\r\n        session: null\r\n      };\r\n    }\r\n\r\n    console.warn('ðŸš€ MODO FORÃ‡ADO ATIVADO - Tentando buscar Ãºltimos dados vÃ¡lidos...');\r\n    \r\n    const results = {\r\n      drivers: [],\r\n      positions: [],\r\n      laps: [],\r\n      intervals: [],\r\n      locations: [],\r\n      pitStops: [],\r\n      stints: [],\r\n      weather: [],\r\n      teamRadio: [],\r\n      raceControl: [],\r\n      session: null,\r\n      classification: []\r\n    };\r\n\r\n    // Tentar buscar cada endpoint com timeout e tratamento de erro individual\r\n    // Lote 1 - Drivers\r\n    try {\r\n      results.drivers = await getDrivers(sessionKey);\r\n      console.log('âœ… Drivers carregados:', results.drivers.length);\r\n    } catch (e) {\r\n      console.warn('âŒ Erro ao carregar drivers:', e.message);\r\n    }\r\n    await delay(3000);\r\n\r\n    // Lote 1.5 - ClassificaÃ§Ã£o final\r\n    try {\r\n      results.classification = await getRaceClassification(sessionKey);\r\n      console.log('âœ… ClassificaÃ§Ã£o carregada:', results.classification.length);\r\n    } catch (e) {\r\n      console.warn('âŒ Erro ao carregar classificaÃ§Ã£o:', e.message);\r\n    }\r\n    await delay(3000);\r\n\r\n    // Lote 2 - Laps (apenas Ãºltimas voltas)\r\n    try {\r\n      results.laps = await getLaps(sessionKey);\r\n      console.log('âœ… Laps carregados:', results.laps.length);\r\n    } catch (e) {\r\n      console.warn('âŒ Erro ao carregar laps:', e.message);\r\n    }\r\n    await delay(3000);\r\n\r\n    // Lote 3 - Intervals (apenas Ãºltimos)\r\n    try {\r\n      results.intervals = await getIntervals(sessionKey);\r\n      console.log('âœ… Intervals carregados:', results.intervals.length);\r\n    } catch (e) {\r\n      console.warn('âŒ Erro ao carregar intervals:', e.message);\r\n    }\r\n    await delay(3000);\r\n\r\n    // Lote 4 - Positions (apenas Ãºltimos)\r\n    try {\r\n      results.positions = await getPositions(sessionKey);\r\n      console.log('âœ… Positions carregados:', results.positions.length);\r\n    } catch (e) {\r\n      console.warn('âŒ Erro ao carregar positions:', e.message);\r\n    }\r\n    await delay(3000);\r\n\r\n    // Lote 5 - Stints\r\n    try {\r\n      results.stints = await getStints(sessionKey);\r\n      console.log('âœ… Stints carregados:', results.stints.length);\r\n    } catch (e) {\r\n      console.warn('âŒ Erro ao carregar stints:', e.message);\r\n    }\r\n    await delay(3000);\r\n\r\n    // Lote 6 - Team Radio (Ãºltimas 20 mensagens)\r\n    try {\r\n      results.teamRadio = await getTeamRadio(sessionKey);\r\n      console.log('âœ… Team Radio carregado:', results.teamRadio.length);\r\n    } catch (e) {\r\n      console.warn('âŒ Erro ao carregar team radio:', e.message);\r\n    }\r\n    await delay(3000);\r\n\r\n    // Lote 7 - Weather (tentar buscar Ãºltimos dados climÃ¡ticos)\r\n    try {\r\n      console.log('â³ Tentando carregar Weather...');\r\n      const weatherResponse = await axios.get(`${BASE_URL}/weather?session_key=${sessionKey}`);\r\n      const weatherData = weatherResponse.data;\r\n      // Pegar apenas os Ãºltimos 10 registros\r\n      results.weather = weatherData.length > 10 ? weatherData.slice(-10) : weatherData;\r\n      console.log('âœ… Weather carregado:', results.weather.length);\r\n    } catch (e) {\r\n      console.warn('âŒ Erro ao carregar weather:', e.message);\r\n      results.weather = [];\r\n    }\r\n    await delay(3000);\r\n\r\n    // Lote 8 - Location (usar funÃ§Ã£o otimizada)\r\n    try {\r\n      console.log('â³ Tentando carregar Location (Ãºltimos 30s)...');\r\n      results.locations = await getLocations(sessionKey);\r\n    } catch (e) {\r\n      console.warn('âŒ Erro ao carregar location:', e.message);\r\n      results.locations = [];\r\n    }\r\n    await delay(3000);\r\n\r\n    // Lote 9 - Race Control (Ãºltimos 30 eventos)\r\n    try {\r\n      console.log('â³ Tentando carregar Race Control...');\r\n      const raceControlResponse = await axios.get(`${BASE_URL}/race_control?session_key=${sessionKey}`);\r\n      const raceControlData = raceControlResponse.data;\r\n      // Pegar apenas os Ãºltimos 30 eventos\r\n      results.raceControl = raceControlData.length > 30 ? raceControlData.slice(-30) : raceControlData;\r\n      console.log('âœ… Race Control carregado:', results.raceControl.length);\r\n    } catch (e) {\r\n      console.warn('âŒ Erro ao carregar race control:', e.message);\r\n      results.raceControl = [];\r\n    }\r\n\r\n    console.log('ðŸ Carregamento forÃ§ado concluÃ­do!');\r\n    console.log('ðŸ“Š Resumo:', {\r\n      drivers: results.drivers.length,\r\n      positions: results.positions.length,\r\n      laps: results.laps.length,\r\n      intervals: results.intervals.length,\r\n      stints: results.stints.length,\r\n      teamRadio: results.teamRadio.length,\r\n      weather: results.weather.length,\r\n      locations: results.locations.length,\r\n      raceControl: results.raceControl.length\r\n    });\r\n    \r\n    return results;\r\n\r\n  } catch (error) {\r\n    console.error('Erro geral ao buscar dados forÃ§ados:', error);\r\n    return { \r\n      drivers: [], \r\n      positions: [], \r\n      laps: [], \r\n      intervals: [], \r\n      locations: [], \r\n      pitStops: [], \r\n      stints: [],\r\n      weather: [],\r\n      teamRadio: [],\r\n      raceControl: [],\r\n      session: null\r\n    };\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para obter dados completos de uma sessÃ£o especÃ­fica\r\nexport const getSessionData = async (sessionKey) => {\r\n  try {\r\n    if (!sessionKey) {\r\n      return { \r\n        drivers: [], \r\n        positions: [], \r\n        laps: [], \r\n        intervals: [], \r\n        locations: [], \r\n        pitStops: [], \r\n        stints: [],\r\n        weather: [],\r\n        teamRadio: [],\r\n        raceControl: [],\r\n        session: null,\r\n        classification: []\r\n      };\r\n    }\r\n\r\n    // ESTRATÃ‰GIA CONSERVADORA: Para sessÃµes com muitos dados histÃ³ricos (como 9869),\r\n    // vamos buscar apenas os dados ESSENCIAIS para evitar exceder 4MB/10s\r\n    \r\n    // Lote 1 - APENAS drivers (pequeno, sempre funciona)\r\n    const drivers = await getDrivers(sessionKey);\r\n    \r\n    await delay(2000); // Aguardar 2 segundos\r\n    \r\n    // Buscar classificaÃ§Ã£o final baseada nas voltas\r\n    const classification = await getRaceClassification(sessionKey);\r\n    \r\n    await delay(2000);\r\n    \r\n    // Todos os outros dados desabilitados temporariamente devido aos limites da API\r\n    // A sessÃ£o selecionada (9869) contÃ©m dados histÃ³ricos muito grandes\r\n    const positions = [];\r\n    const laps = [];\r\n    const intervals = [];\r\n    const stints = [];\r\n    const teamRadio = [];\r\n    const locations = [];\r\n    const pitStops = [];\r\n    const raceControl = [];\r\n    const weather = [];\r\n\r\n    // Buscar informaÃ§Ãµes da sessÃ£o\r\n    const sessionResponse = await axios.get(`${BASE_URL}/sessions?session_key=${sessionKey}`);\r\n    const session = sessionResponse.data.length > 0 ? sessionResponse.data[0] : null;\r\n\r\n    return { \r\n      drivers, \r\n      positions, \r\n      laps, \r\n      intervals, \r\n      locations, \r\n      pitStops, \r\n      stints, \r\n      weather, \r\n      teamRadio, \r\n      raceControl, \r\n      session,\r\n      classification\r\n    };\r\n  } catch (error) {\r\n    console.error('Erro ao buscar dados da sessÃ£o:', error);\r\n    return { \r\n      drivers: [], \r\n      positions: [], \r\n      laps: [], \r\n      intervals: [], \r\n      locations: [], \r\n      pitStops: [], \r\n      stints: [],\r\n      weather: [],\r\n      teamRadio: [],\r\n      raceControl: [],\r\n      session: null,\r\n      classification: []\r\n    };\r\n  }\r\n};\r\n\r\n// FunÃ§Ã£o para processar e combinar dados\r\nexport const getFullRaceData = async (sessionKey = null, forceLoad = false) => {\r\n  try {\r\n    let session = null;\r\n    let targetSessionKey = sessionKey;\r\n\r\n    // Se nÃ£o foi fornecido sessionKey, buscar a Ãºltima sessÃ£o\r\n    if (!targetSessionKey) {\r\n      session = await getLatestSession();\r\n      if (!session) {\r\n        return { \r\n          drivers: [], \r\n          positions: [], \r\n          laps: [], \r\n          intervals: [], \r\n          locations: [], \r\n          pitStops: [], \r\n          stints: [],\r\n          weather: [],\r\n          teamRadio: [],\r\n          raceControl: [],\r\n          session: null\r\n        };\r\n      }\r\n      targetSessionKey = session.session_key;\r\n    }\r\n\r\n    // Buscar dados da sessÃ£o especÃ­fica\r\n    const data = forceLoad \r\n      ? await getSessionDataForced(targetSessionKey)\r\n      : await getSessionData(targetSessionKey);\r\n    \r\n    // Se a sessÃ£o nÃ£o foi buscada ainda, buscar agora\r\n    if (!data.session && targetSessionKey) {\r\n      const sessionResponse = await axios.get(`${BASE_URL}/sessions?session_key=${targetSessionKey}`);\r\n      data.session = sessionResponse.data.length > 0 ? sessionResponse.data[0] : session;\r\n    } else if (!data.session) {\r\n      data.session = session;\r\n    }\r\n\r\n    return data;\r\n  } catch (error) {\r\n    console.error('Erro ao buscar dados completos:', error);\r\n    return { \r\n      drivers: [], \r\n      positions: [], \r\n      laps: [], \r\n      intervals: [], \r\n      locations: [], \r\n      pitStops: [], \r\n      stints: [],\r\n      weather: [],\r\n      teamRadio: [],\r\n      raceControl: [],\r\n      session: null\r\n    };\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}